<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Overture Maps Browser</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        #map { height: 100vh; width: 100%; }
        #controls {
            position: absolute; top: 10px; right: 10px; z-index: 1000;
            background: white; padding: 20px; border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            display: flex; flex-direction: column; gap: 16px; min-width: 260px;
        }
        #status {
            font-size: 13px; color: #666; padding: 10px 12px;
            background: #f8f9fa; border-radius: 8px;
            display: flex; align-items: center; gap: 8px;
        }
        #status.loading { background: #fff3cd; color: #856404; }
        #status.error { background: #f8d7da; color: #721c24; }
        #status.success { background: #d4edda; color: #155724; }
        .spinner {
            width: 14px; height: 14px; border: 2px solid #ccc;
            border-top-color: #007bff; border-radius: 50%;
            animation: spin 0.8s linear infinite; display: none;
        }
        #status.loading .spinner { display: block; }
        @keyframes spin { to { transform: rotate(360deg); } }
        label {
            display: flex; align-items: center; gap: 8px;
            cursor: pointer; font-size: 14px; font-weight: 500;
        }
        input[type="checkbox"] {
            width: 18px; height: 18px; accent-color: #007bff; cursor: pointer;
        }
        .slider-row { display: flex; flex-direction: column; gap: 6px; }
        .slider-header { display: flex; justify-content: space-between; font-size: 13px; color: #666; }
        .slider-value { font-weight: 600; color: #007bff; }
        input[type="range"] {
            width: 100%; height: 6px; -webkit-appearance: none;
            background: linear-gradient(to right, #e0e0e0, #007bff); border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 18px; height: 18px;
            background: #007bff; border-radius: 50%; cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        button {
            padding: 12px 20px; cursor: pointer; background: #007bff; color: white;
            border: none; border-radius: 8px; font-size: 14px; font-weight: 600;
            transition: all 0.2s;
        }
        button:hover:not(:disabled) { background: #0056b3; transform: translateY(-1px); }
        button:disabled { background: #ccc; cursor: not-allowed; }
        #catHeader {
            display: flex; justify-content: space-between; align-items: center;
            font-size: 13px; color: #666; cursor: pointer; padding: 8px 0;
        }
        #catHeader:hover { color: #007bff; }
        #categories {
            display: none; flex-direction: column; gap: 4px;
            max-height: 180px; overflow-y: auto;
            background: #f8f9fa; border-radius: 8px; padding: 10px;
        }
        #categories.visible { display: flex; }
        #categories label { font-size: 13px; font-weight: 400; padding: 2px 0; }
        .cat-count { color: #888; font-size: 11px; margin-left: 4px; }
        .cat-buttons { display: flex; gap: 8px; margin-bottom: 8px; }
        .cat-buttons button { padding: 4px 10px; font-size: 11px; }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="controls">
        <div id="status" class="loading">
            <div class="spinner"></div>
            <span>Initializing...</span>
        </div>
        <label><input type="checkbox" id="buildingsCheck"> Load buildings near places</label>
        <div class="slider-row">
            <div class="slider-header">
                <span>Building distance</span>
                <span class="slider-value" id="distanceValue">0m</span>
            </div>
            <input type="range" id="distanceSlider" min="0" max="50" value="0" step="5">
        </div>
        <div class="slider-row">
            <div class="slider-header">
                <span>Limit</span>
                <span class="slider-value" id="limitValue">33,000</span>
            </div>
            <input type="range" id="limitSlider" min="33000" max="1000000" value="33000" step="1000">
        </div>
        <button id="loadBtn" disabled>Load Data</button>
        <div id="catSection" style="display:none">
            <div id="catHeader">
                <span>Categories <span id="catCount"></span></span>
                <span id="catToggle">â–¼</span>
            </div>
            <div id="categories"></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script type="module">
        import * as duckdb from 'https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm';

        const $ = id => document.getElementById(id);
        const PROXY = `${location.origin}/s3`;
        const RELEASE = '2026-01-21.0';

        let conn = null;
        let placeMarkers = []; // {marker, cat}
        let buildingMarkers = []; // {layer, cats: Set}
        const placesLayer = L.layerGroup();
        const buildingsLayer = L.layerGroup();
        const CACHE_KEY = `overture_files_${RELEASE}`;
        const fileCache = JSON.parse(localStorage.getItem(CACHE_KEY) || '{}');

        $('limitSlider').oninput = () => $('limitValue').textContent = parseInt($('limitSlider').value).toLocaleString();
        $('distanceSlider').oninput = () => $('distanceValue').textContent = $('distanceSlider').value + 'm';
        $('catHeader').onclick = () => $('categories').classList.toggle('visible');

        // Map setup
        const [z, lat, lon] = (location.hash.slice(1) || '').split('/').map(Number);
        const map = L.map('map').setView(
            (!isNaN(lat) && !isNaN(lon)) ? [lat, lon] : [34.05, -118.25],
            !isNaN(z) ? z : 14
        );
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
        placesLayer.addTo(map);
        buildingsLayer.addTo(map);

        map.on('moveend', () => {
            const c = map.getCenter();
            history.replaceState(null, '', `#${map.getZoom()}/${c.lat.toFixed(5)}/${c.lng.toFixed(5)}`);
        });

        function log(msg, type = 'loading') {
            $('status').innerHTML = `<div class="spinner"></div><span>${msg}</span>`;
            $('status').className = type;
        }

        function getBbox() {
            const b = map.getBounds();
            return { xmin: b.getWest(), xmax: b.getEast(), ymin: b.getSouth(), ymax: b.getNorth() };
        }

        function bboxWhere(bbox, prefix = '') {
            const p = prefix ? prefix + '.' : '';
            return `${p}bbox.xmin >= ${bbox.xmin} AND ${p}bbox.xmax <= ${bbox.xmax} AND ${p}bbox.ymin >= ${bbox.ymin} AND ${p}bbox.ymax <= ${bbox.ymax}`;
        }

        async function listFiles(theme, type) {
            const key = `${theme}/${type}`;
            if (fileCache[key]) return fileCache[key];

            let files = [], marker = '';
            while (true) {
                const url = `${PROXY}/?prefix=release/${RELEASE}/theme=${theme}/type=${type}/&max-keys=1000${marker ? '&marker=' + marker : ''}`;
                const xml = new DOMParser().parseFromString(await (await fetch(url)).text(), 'text/xml');
                const keys = [...xml.querySelectorAll('Key')].map(k => k.textContent);
                files.push(...keys.map(k => `${PROXY}/${k}`));
                if (xml.querySelector('IsTruncated')?.textContent !== 'true') break;
                marker = encodeURIComponent(keys[keys.length - 1]);
            }
            fileCache[key] = files;
            localStorage.setItem(CACHE_KEY, JSON.stringify(fileCache));
            return files;
        }

        function filterPlaces() {
            const checked = new Set([...$('categories').querySelectorAll('input[data-cat]:checked')].map(cb => cb.dataset.cat));
            let visiblePlaces = 0;
            for (const { marker, cat } of placeMarkers) {
                if (checked.has(cat)) {
                    if (!placesLayer.hasLayer(marker)) placesLayer.addLayer(marker);
                    visiblePlaces++;
                } else {
                    placesLayer.removeLayer(marker);
                }
            }
            // Also filter buildings - show if any of its associated categories are checked
            let visibleBuildings = 0;
            for (const { layer, cats } of buildingMarkers) {
                const hasVisibleCat = [...cats].some(c => checked.has(c));
                if (hasVisibleCat) {
                    if (!buildingsLayer.hasLayer(layer)) buildingsLayer.addLayer(layer);
                    visibleBuildings++;
                } else {
                    buildingsLayer.removeLayer(layer);
                }
            }
            log(`${visiblePlaces.toLocaleString()} places, ${visibleBuildings} buildings`, 'success');
        }

        function buildCategoryUI(catCounts) {
            const container = $('categories');
            container.innerHTML = '';

            const btns = document.createElement('div');
            btns.className = 'cat-buttons';
            btns.innerHTML = `<button type="button">All</button><button type="button">None</button>`;
            btns.children[0].onclick = () => { container.querySelectorAll('input').forEach(c => c.checked = true); filterPlaces(); };
            btns.children[1].onclick = () => { container.querySelectorAll('input').forEach(c => c.checked = false); filterPlaces(); };
            container.appendChild(btns);

            for (const [cat, cnt] of catCounts) {
                const label = document.createElement('label');
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.checked = true;
                input.dataset.cat = cat;
                input.onchange = filterPlaces;
                label.appendChild(input);
                label.append(` ${cat || 'uncategorized'} `);
                const span = document.createElement('span');
                span.className = 'cat-count';
                span.textContent = `(${cnt})`;
                label.appendChild(span);
                container.appendChild(label);
            }

            $('catCount').textContent = `(${catCounts.length})`;
            $('catSection').style.display = 'block';
            container.classList.add('visible');
        }

        async function loadData() {
            const bbox = getBbox();
            const limit = parseInt($('limitSlider').value);

            placesLayer.clearLayers();
            buildingsLayer.clearLayers();
            placeMarkers = [];
            $('loadBtn').disabled = true;

            try {
                // Load places
                log('Loading places...');
                const placeFiles = await listFiles('places', 'place');
                const placeFileList = placeFiles.map(f => `'${f}'`).join(',');

                const q = `SELECT names.primary as name, categories.primary as cat,
                    ST_X(geometry) as lon, ST_Y(geometry) as lat
                    FROM read_parquet([${placeFileList}], hive_partitioning=false)
                    WHERE ${bboxWhere(bbox)}
                    LIMIT ${limit}`;

                const rows = (await conn.query(q)).toArray();
                log(`Rendering ${rows.length} places...`);

                const catCounts = {};
                for (const r of rows) {
                    const cat = r.cat || '';
                    catCounts[cat] = (catCounts[cat] || 0) + 1;
                    if (r.lat && r.lon) {
                        const marker = L.circleMarker([Number(r.lat), Number(r.lon)], {
                            radius: 5, fillColor: '#e74c3c', color: '#c0392b', weight: 1, fillOpacity: 0.8
                        }).bindPopup(`<b>${r.name || '?'}</b><br>${cat}`);
                        marker.addTo(placesLayer);
                        placeMarkers.push({ marker, cat });
                    }
                }

                const sortedCats = Object.entries(catCounts).sort((a, b) => b[1] - a[1]);
                buildCategoryUI(sortedCats);

                // Load buildings where bbox overlaps with place bbox + distance buffer
                buildingMarkers = [];
                if ($('buildingsCheck').checked) {
                    log('Loading buildings...');
                    const buildingFiles = await listFiles('buildings', 'building');
                    const buildingFileList = buildingFiles.map(f => `'${f}'`).join(',');

                    const distMeters = parseInt($('distanceSlider').value);
                    const d = distMeters / 111000; // ~111km per degree

                    // Create temp table with place bboxes + category
                    await conn.query(`DROP TABLE IF EXISTS temp_places`);
                    await conn.query(`CREATE TEMP TABLE temp_places AS
                        SELECT categories.primary as cat,
                               bbox.xmin as xmin, bbox.xmax as xmax, bbox.ymin as ymin, bbox.ymax as ymax
                        FROM read_parquet([${placeFileList}], hive_partitioning=false)
                        WHERE ${bboxWhere(bbox)}
                        LIMIT ${limit}`);

                    // Buildings with their overlapping place categories
                    const bq = `SELECT ST_AsGeoJSON(b.geometry) as geojson,
                               LIST(DISTINCT COALESCE(p.cat, '')) as cats
                        FROM read_parquet([${buildingFileList}], hive_partitioning=false) b
                        JOIN temp_places p ON
                             b.bbox.xmax >= p.xmin - ${d} AND b.bbox.xmin <= p.xmax + ${d}
                             AND b.bbox.ymax >= p.ymin - ${d} AND b.bbox.ymin <= p.ymax + ${d}
                        WHERE ${bboxWhere(bbox, 'b')}
                        GROUP BY b.geometry`;

                    const buildings = (await conn.query(bq)).toArray();
                    log(`Rendering ${buildings.length} buildings...`);

                    for (const r of buildings) {
                        if (r.geojson) {
                            const layer = L.geoJSON(JSON.parse(r.geojson), {
                                style: { fillColor: '#3388ff', color: '#2266cc', weight: 1, fillOpacity: 0.5 }
                            });
                            layer.addTo(buildingsLayer);
                            const cats = new Set(r.cats || []);
                            buildingMarkers.push({ layer, cats });
                        }
                    }
                }

                log(`${placeMarkers.length} places, ${buildingMarkers.length} buildings`, 'success');
            } catch (e) {
                log(`Error: ${e.message}`, 'error');
                console.error(e);
            } finally {
                $('loadBtn').disabled = false;
            }
        }

        async function init() {
            try {
                log('Loading DuckDB...');
                const bundles = duckdb.getJsDelivrBundles();
                const bundle = await duckdb.selectBundle(bundles);
                const worker = new Worker(URL.createObjectURL(
                    new Blob([`importScripts("${bundle.mainWorker}");`], { type: 'text/javascript' })
                ));
                const db = new duckdb.AsyncDuckDB(new duckdb.ConsoleLogger(), worker);
                await db.instantiate(bundle.mainModule, bundle.pthreadWorker);
                conn = await db.connect();
                await conn.query('INSTALL spatial; LOAD spatial;');

                log('Ready', 'success');
                $('loadBtn').disabled = false;

                // Preload file lists in background
                if (!fileCache['places/place']) {
                    log('Caching file lists...');
                    await listFiles('places', 'place');
                    await listFiles('buildings', 'building');
                    log('Ready', 'success');
                }
            } catch (e) {
                log(`Init error: ${e.message}`, 'error');
            }
        }

        $('loadBtn').onclick = loadData;
        init();
    </script>
</body>
</html>
