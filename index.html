<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Overture Maps Browser</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        #map { height: 100vh; width: 100%; }
        #controls {
            position: absolute; top: 10px; right: 10px; z-index: 1000;
            background: white; padding: 20px; border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            display: flex; flex-direction: column; gap: 16px; min-width: 260px;
        }
        #status {
            font-size: 13px; color: #666; padding: 10px 12px;
            background: #f8f9fa; border-radius: 8px;
            display: flex; align-items: center; gap: 8px;
        }
        #status.loading { background: #fff3cd; color: #856404; }
        #status.error { background: #f8d7da; color: #721c24; }
        #status.success { background: #d4edda; color: #155724; }
        .spinner {
            width: 14px; height: 14px; border: 2px solid #ccc;
            border-top-color: #007bff; border-radius: 50%;
            animation: spin 0.8s linear infinite; display: none;
        }
        #status.loading .spinner { display: block; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .row { display: flex; gap: 16px; align-items: center; }
        label {
            display: flex; align-items: center; gap: 8px;
            cursor: pointer; font-size: 14px; font-weight: 500;
        }
        input[type="checkbox"] {
            width: 18px; height: 18px; accent-color: #007bff; cursor: pointer;
        }
        .slider-row { display: flex; flex-direction: column; gap: 6px; }
        .slider-header { display: flex; justify-content: space-between; font-size: 13px; color: #666; }
        .slider-value { font-weight: 600; color: #007bff; }
        input[type="range"] {
            width: 100%; height: 6px; -webkit-appearance: none;
            background: linear-gradient(to right, #e0e0e0, #007bff); border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 18px; height: 18px;
            background: #007bff; border-radius: 50%; cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        button {
            padding: 12px 20px; cursor: pointer; background: #007bff; color: white;
            border: none; border-radius: 8px; font-size: 14px; font-weight: 600;
            transition: all 0.2s;
        }
        button:hover:not(:disabled) { background: #0056b3; transform: translateY(-1px); }
        button:disabled { background: #ccc; cursor: not-allowed; }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="controls">
        <div id="status" class="loading">
            <div class="spinner"></div>
            <span>Initializing...</span>
        </div>
        <div class="row">
            <label><input type="checkbox" id="placesCheck" checked> Places</label>
            <label><input type="checkbox" id="buildingsCheck"> Buildings</label>
        </div>
        <div class="slider-row">
            <div class="slider-header">
                <span>Limit</span>
                <span class="slider-value" id="limitValue">1,000</span>
            </div>
            <input type="range" id="limitSlider" min="100" max="50000" value="1000" step="100">
        </div>
        <button id="loadBtn" disabled>Load Data</button>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script type="module">
        import * as duckdb from 'https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm';

        const $ = id => document.getElementById(id);
        const status = $('status');
        const loadBtn = $('loadBtn');
        const placesCheck = $('placesCheck');
        const buildingsCheck = $('buildingsCheck');
        const limitSlider = $('limitSlider');
        const limitValue = $('limitValue');

        limitSlider.oninput = () => limitValue.textContent = parseInt(limitSlider.value).toLocaleString();

        const PROXY = `${location.origin}/s3`;
        const RELEASE = '2026-01-21.0';

        let conn = null;
        const layers = L.layerGroup();
        const fileCache = {};
        const bboxCache = {}; // file -> {xmin, xmax, ymin, ymax} bounds

        // Map setup with URL hash
        function getInitialView() {
            const [z, lat, lon] = (location.hash.slice(1) || '').split('/').map(Number);
            return (!isNaN(z) && !isNaN(lat) && !isNaN(lon))
                ? { center: [lat, lon], zoom: z }
                : { center: [34.05, -118.25], zoom: 14 };
        }

        const { center, zoom } = getInitialView();
        const map = L.map('map').setView(center, zoom);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
        layers.addTo(map);

        map.on('moveend', () => {
            const c = map.getCenter();
            history.replaceState(null, '', `#${map.getZoom()}/${c.lat.toFixed(5)}/${c.lng.toFixed(5)}`);
        });

        function log(msg, type = 'loading') {
            status.innerHTML = `<div class="spinner"></div><span>${msg}</span>`;
            status.className = type;
            console.log(msg);
        }

        async function listFiles(theme, type) {
            const key = `${theme}/${type}`;
            if (fileCache[key]) return fileCache[key];

            let files = [];
            let marker = '';
            let page = 0;
            while (true) {
                page++;
                if (page > 1) log(`Listing ${type}s (page ${page})...`);

                const url = `${PROXY}/?prefix=release/${RELEASE}/theme=${theme}/type=${type}/&max-keys=1000${marker ? '&marker=' + marker : ''}`;
                const resp = await fetch(url);
                const xml = new DOMParser().parseFromString(await resp.text(), 'text/xml');
                const keys = [...xml.querySelectorAll('Key')].map(k => k.textContent);
                files.push(...keys.map(k => `${PROXY}/${k}`));

                const isTruncated = xml.querySelector('IsTruncated')?.textContent === 'true';
                if (!isTruncated || keys.length === 0) break;
                marker = encodeURIComponent(keys[keys.length - 1]);
            }
            log(`Found ${files.length} ${type} files`);
            fileCache[key] = files;
            return files;
        }

        async function init() {
            try {
                log('Loading DuckDB...');
                const bundles = duckdb.getJsDelivrBundles();
                const bundle = await duckdb.selectBundle(bundles);
                const worker = new Worker(URL.createObjectURL(
                    new Blob([`importScripts("${bundle.mainWorker}");`], { type: 'text/javascript' })
                ));
                const db = new duckdb.AsyncDuckDB(new duckdb.ConsoleLogger(), worker);
                await db.instantiate(bundle.mainModule, bundle.pthreadWorker);
                conn = await db.connect();

                log('Loading spatial extension...');
                await conn.query('INSTALL spatial; LOAD spatial;');

                log('Ready - click Load', 'success');
                loadBtn.disabled = false;
            } catch (e) {
                log(`Init error: ${e.message}`, 'error');
            }
        }

        async function loadData() {
            const b = map.getBounds();
            const bbox = { xmin: b.getWest(), xmax: b.getEast(), ymin: b.getSouth(), ymax: b.getNorth() };
            const limit = parseInt(limitSlider.value);

            layers.clearLayers();
            loadBtn.disabled = true;

            let totalPlaces = 0, totalBuildings = 0;

            try {
                if (placesCheck.checked) {
                    log('Places: listing files...');
                    const files = await listFiles('places', 'place');
                    log(`Places: scanning ${files.length} files (using metadata)...`);
                    const fileList = files.map(f => `'${f}'`).join(',');

                    // hive_partitioning and file_row_number help DuckDB use parquet stats
                    const q = `SELECT names.primary as name, categories.primary as cat,
                        ST_X(geometry) as lon, ST_Y(geometry) as lat
                        FROM read_parquet([${fileList}], hive_partitioning=false)
                        WHERE bbox.xmin >= ${bbox.xmin} AND bbox.xmax <= ${bbox.xmax}
                        AND bbox.ymin >= ${bbox.ymin} AND bbox.ymax <= ${bbox.ymax}
                        LIMIT ${limit}`;

                    const rows = (await conn.query(q)).toArray();
                    log(`Places: rendering ${rows.length.toLocaleString()} markers...`);

                    for (let i = 0; i < rows.length; i++) {
                        const r = rows[i];
                        if (r.lat && r.lon) {
                            L.circleMarker([Number(r.lat), Number(r.lon)], {
                                radius: 5, fillColor: '#e74c3c', color: '#c0392b', weight: 1, fillOpacity: 0.8
                            }).bindPopup(`<b>${r.name || '?'}</b><br>${r.cat || ''}`).addTo(layers);
                            totalPlaces++;
                        }
                        if (i % 5000 === 0 && i > 0) {
                            log(`Places: rendered ${i.toLocaleString()} / ${rows.length.toLocaleString()}...`);
                            await new Promise(r => setTimeout(r, 0)); // yield to UI
                        }
                    }
                }

                if (buildingsCheck.checked) {
                    log('Buildings: listing files...');
                    const files = await listFiles('buildings', 'building');

                    // Get or build bbox cache for files
                    let relevantFiles = files;
                    const cacheKey = 'buildings/building';

                    if (!bboxCache[cacheKey]) {
                        log(`Buildings: reading metadata (first time, will cache)...`);
                        bboxCache[cacheKey] = {};

                        // Read min/max bbox from each file (can parallelize later)
                        for (let i = 0; i < files.length; i++) {
                            if (i % 20 === 0) log(`Buildings: caching metadata ${i}/${files.length}...`);
                            try {
                                const metaQ = `SELECT
                                    MIN(bbox.xmin) as xmin, MAX(bbox.xmax) as xmax,
                                    MIN(bbox.ymin) as ymin, MAX(bbox.ymax) as ymax
                                    FROM read_parquet('${files[i]}')`;
                                const meta = (await conn.query(metaQ)).toArray()[0];
                                bboxCache[cacheKey][files[i]] = {
                                    xmin: Number(meta.xmin), xmax: Number(meta.xmax),
                                    ymin: Number(meta.ymin), ymax: Number(meta.ymax)
                                };
                            } catch (e) {
                                console.warn(`Failed to read metadata for ${files[i]}:`, e);
                            }
                        }
                        console.log('Cached bbox metadata for', Object.keys(bboxCache[cacheKey]).length, 'files');
                    }

                    // Filter files by bbox overlap
                    relevantFiles = files.filter(f => {
                        const fb = bboxCache[cacheKey][f];
                        if (!fb) return true; // include if no metadata
                        // Check if file bbox overlaps with query bbox
                        return !(fb.xmax < bbox.xmin || fb.xmin > bbox.xmax ||
                                 fb.ymax < bbox.ymin || fb.ymin > bbox.ymax);
                    });

                    log(`Buildings: ${relevantFiles.length}/${files.length} files match bbox`);

                    if (relevantFiles.length === 0) {
                        log(`No building files cover this area`, 'error');
                    } else {
                        const fileList = relevantFiles.map(f => `'${f}'`).join(',');
                        const q = `SELECT height, class, ST_AsGeoJSON(geometry) as geojson
                            FROM read_parquet([${fileList}], hive_partitioning=false)
                            WHERE bbox.xmin >= ${bbox.xmin} AND bbox.xmax <= ${bbox.xmax}
                            AND bbox.ymin >= ${bbox.ymin} AND bbox.ymax <= ${bbox.ymax}
                            LIMIT ${limit}`;

                        const rows = (await conn.query(q)).toArray();
                        log(`Buildings: rendering ${rows.length.toLocaleString()} polygons...`);

                        for (let i = 0; i < rows.length; i++) {
                            const r = rows[i];
                            try {
                                if (!r.geojson) continue;
                                const geo = JSON.parse(r.geojson);
                                L.geoJSON(geo, {
                                    style: { fillColor: '#3388ff', color: '#2266cc', weight: 1, fillOpacity: 0.5 }
                                }).bindPopup(`${r.class || 'building'}<br>${r.height ? r.height + 'm' : ''}`).addTo(layers);
                                totalBuildings++;
                            } catch (e) {}
                            if (i % 2000 === 0 && i > 0) {
                                log(`Buildings: rendered ${i.toLocaleString()} / ${rows.length.toLocaleString()}...`);
                                await new Promise(r => setTimeout(r, 0));
                            }
                        }
                    }
                }

                log(`Loaded: ${totalPlaces.toLocaleString()} places, ${totalBuildings.toLocaleString()} buildings`, 'success');
            } catch (e) {
                log(`Error: ${e.message}`, 'error');
                console.error(e);
            } finally {
                loadBtn.disabled = false;
            }
        }

        loadBtn.onclick = loadData;
        init();
    </script>
</body>
</html>
